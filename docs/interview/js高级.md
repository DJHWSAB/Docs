---
layout: doc
---

# js高级

## 1. this的绑定规则有⼏种？

- 默认绑定：独⽴函数调⽤，函数没有被绑定到某个对象上进⾏调⽤
- 隐式绑定：通过某个对象发起的函数调⽤，在调⽤对象内部有⼀个对函数的引⽤。
- 显式绑定：明确this指向的对象，第⼀个参数相同并要求传⼊⼀个对象。
  - apply/call
  - bind
- new绑定：
  - 创建⼀个全新对象
  - 新对象被执⾏prototype链接
  - 新对象绑定到函数调⽤的this
  - 如果函数没有返回其他对象，表达式会返回这个对象

## 2. 说出apply、call、bind函数的⽤法和区别？

  - ⽤法：
    - apply
      - 第⼀个参数: 绑定this
      - 第⼆个参数: 传⼊额外的实参, 以数组的形式
    - call
      - 第⼀个参数: 绑定this
      - 参数列表: 后续的参数以多参数的形式传递, 会作为实参
    - bind(不希望obj对象身上有函数)

  - 区别：
    - call、apply和bind都可以改变函数的this指向
    - call、apply和bind第⼀个参数的是this要指向的对象
    - call、apply和bind都可以后续为函数传参，apply是将参数并成⼀个数组，call和bind是将参数依次列出
    - call、apply都是直接调⽤，bind⽣成的this指向改变函数需要⼿动调⽤。

## 3. 说说你对作⽤域和作⽤域链的理解？

  - 作⽤域
    - 在ES5中，全局是⼀个作⽤域，函数也会产⽣作⽤域。
    - 在ES6中，代码块、let、const等都会有属于⾃⼰的作⽤域。
  - 作⽤域链
    - 当进⼊到⼀个执⾏上下⽂时，执⾏上下⽂会关联⼀个作⽤域链。
    - 通常作用域链在解析时就被确定， 因此作用域链与函数的定义位置有关，而与它的调用位置无关


## 4. 浏览器输入一个URL到页面显示的过程

  - 首先在浏览器中输入域名，通过DNS服务器进行域名解析
  - 解析出对应的IP地址 然后从ip地址对应的主机发送http请求 获取对应的静态资源
  - 默认情况服务器会返回index.html文件
  - 然后浏览器内核开始解析HTML
  - 首先 会解析对应的html 生成 <font color="red">DOM Tree</font>
  - 解析过程中 如果遇到css的link标签 则会下载对应的css文件
    - 下载css文件和生成DOM树是同时进行
  - 下载完对应的css文件后会进行css解析 生成 <font color="red">CSSOM</font> ( CSS object model)
  - 当DOM Tree和CSSTree都解析完成之后 会进行合并用来生成 <font color="red">Render Tree</font> (渲染树)
  - 初步生成的渲染树会显示节点以及部分样式 但是并不表示每个节点的尺寸、位置信息，于是进行 <font color="red">Layout(布局)</font> 来生成渲染树中节点的宽度、高度位置信息
  - 经过Layout之后，浏览器内核将布局时的每个 <font color="red">frame</font> 转为屏幕上的每个像素点，将每个节点绘制到屏幕上

## 5. 网页的渲染过程 / 浏览器是如何渲染UI的？

 - 首先 会解析对应的html 生成 <font color="red">DOM Tree</font>
  - 解析过程中 如果遇到css的link标签 则会下载对应的css文件
    - 下载css文件和生成DOM树是同时进行
  - 下载完对应的css文件后会进行css解析 生成 <font color="red">CSSOM</font> ( CSS object model)
  - 当DOM Tree和CSSTree都解析完成之后 会进行合并用来生成 <font color="red">Render Tree</font> (渲染树)
  - 初步生成的渲染树会显示节点以及部分样式 但是并不表示每个节点的尺寸、位置信息，于是进行 <font color="red">Layout(布局)</font> 来生成渲染树中节点的宽度、高度位置信息
  - 经过Layout之后，浏览器内核将布局时的每个 <font color="red">frame</font> 转为屏幕上的每个像素点，将每个节点绘制到屏幕上

## 6. 回流(重排)/重绘?

### 6.1 什么是回流（重排）

  当页面布局发生改变，需要重新计算元素的位置和尺寸

### 6.2 什么是重绘

  当元素的样式发生改变，但不影响其布局时

### 6.3 什么情况下引起回流（重排）

  - DOM结构发生改变(节点的增删)
  - 修改了节点的布局(宽度 高度 字体大小等)
  - 修改窗口的尺寸
  - 调用getComputedStyle获取尺寸、位置信息

### 6.4 引起重绘情况:

  - 修改背景色、文字颜色、边框颜色、样式等

  `回流一定会引起重绘 所以回流非常消耗性能`

### 6.5 如何避免回流

  - 尽量一次性的修改样式
    - 通过添加classList
  - 避免频繁的操作DOM
  - 避免通过getComputedStyle获取尺寸、位置信息等
  - 对于某些元素使用position:absolute/fixed
    - 开销较小 不会对其他元素造成影响

## 7. 说说async和defer的使⽤以及区别？

- script 会阻塞DOM Tree构建，需要优先下载和执行JavaScript代码，再继续构建DOM Tree
- 为了解决这个问题，script元素给我们提供了两个属性（attribute）：`defer` 和 ` async`

- defer
  - 脚本<font color="red">会由浏览器来进行下载，但是不会阻塞DOM Tree</font>的构建过程；
  - 如果脚本提前下载好了，它会<font color="red">等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码</font>；
  - 同时多个defer属性的script标签会按照顺序执⾏
  - 从性能的角度最好放到head中
  - defer对于script元素没有外部引用是无效的

- async
  - 浏览器<font color="red">不会因 async 脚本而阻塞</font>（与 defer 类似）；
  - <font color="red">async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本</font>；
  - <font color="red">async不能保证在DOMContentLoaded之前或者之后执行</font>；
  - 通常用于独立的脚本，对其他脚本，DOM没有依赖
 
## 8. 说说V8引擎的内存管理

- JavaScript的内存管理是⾃动的
- 关于原始数据类型 直接在栈内存中分配
- 关于复杂数据类型 在堆内存中分配

## 9. 说说V8引擎的垃圾回收器

- 因为内存大小是有限的，所以在内存不需要的时候，需要进行释放，用于腾出空间
- GC对于内存管理有着对应的算法
- 常见的算法
  - 引用计数(Reference Count) 
    - 当一个对象有引用指向它时，对应的引用计数+1 
    - 当没有对象指向它时，则为0，此时进行回收
    - 但是有一个严重的问题 - 会产生循环引用
  - 标记清除(Mark-Sweep)
    - 核心思路: 可达性
    - 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象；对于不可用的对象 则进行回收
    - 该算法有效的解决了循环引用的问题
    - 目前V8引擎采用的就是该算法
- V8引擎为了优化 在采用标记清除的过程中也引用了其他的算法
  - 标记整理
    - 和标记清除相似 不同的是回收时 会将保留下来的存储对象整合到连续的内存空间 避免内存碎片化
  - 分代收集(Generational Collection)
    - 将内存中的对象分为两组 新的空间 旧的空间
    - 对于长期存活的对象 会将该对象从新空间移到旧空间中 同时GC检查次数减少
    - 将新空间分为from和to，对象的GC查找之后从from移动到to空间中，然后to变为from，from变为to，循环几次，对于依然存在的对象，移动到旧空间中
  - 增量收集(Increment Collection)
    - 如果存在许多对象 则GC试图一次性遍历所有的对象 可能会对性能造成一定的影响 
    - 所以引擎试图将垃圾收集工作分成几部分 然后这几部分逐一处理 这样会造成微小的延迟 而不是很大的延迟
  - 闲时收集(IdIe-time Collection)
    - GC只会在CPU空闲的时候运行 减少可能对代码执行造成的影响
   
## 10. 你是如何理解闭包的,闭包到底是什么?

- 什么是闭包？
  - 一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包；
  - <font color="red">从广义的角度来说：JavaScript中的函数都是闭包；</font>
  - <font color="red">从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；</font> 
- 应⽤场景
  - 防抖 、节流 、⽴即执⾏函数 、组合函数等等

## 11. 闭包为什么会产生内存泄露以及如何解决

- 闭包使得原本该销毁的作用域由于内部函数的引用没有销毁 始终存在在堆内存中 因此产生了内存泄露

- 解决
  - 将保存着上层作用域引用的函数在使用完之后置为null将它的引用销毁在GC的下一次检查中 对应的内存就会被销毁

## 12. 什么是纯函数？如何编写纯函数？

- 纯函数⼀般具有以下的特点：
  - 确定的输⼊⼀定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产⽣的结果）
  - 纯函数的执⾏不会产⽣副作⽤。（函数内部的操作也不会对函数外部产⽣任何影响）
- 纯函数在react和redux中应⽤⽐较多。
- 编写纯函数：
```js
  function sum(num1, num2){
    return num1 + num2
  }
```

```js
  //⼀般的数学⽅法可以写成纯函数,例如相加
  function sum(...args) {
    var result = args.reduce((perValue, item) => {
                   return preValue + item
                 }, 0)
    return result
  }
```
